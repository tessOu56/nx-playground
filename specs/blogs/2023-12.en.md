---
id: 2023-12
slug: 2023-12
title: Frontend Architecture Deepening and Enterprise System Collaboration in 2023
year: 2023
publishDate: 2023-12-31
excerpt: Next.js App Router, GraphQL schema-driven development, and enterprise-scale B2B SaaS platform
techStack:
  - Next.js (App Router)
  - React
  - TypeScript
  - GraphQL
  - Apollo Client
  - Node.js
  - NestJS
  - PostgreSQL
  - Server Components
tags:
  - nextjs
  - graphql
  - apollo
  - enterprise
  - performance
  - architecture
coverImage: https://picsum.photos/seed/2023-nx/800/400
---

# Frontend Architecture Deepening and Enterprise System Collaboration in 2023

## ðŸ§­ Joining a Software Development Company

In 2023, I joined a **software development company**, focusing formally on frontend domain development.

The company primarily handled **medium-to-large enterprise projects**. My team developed an **Advertising Business Management System** for a major Asian advertising enterprise.

### Team Composition

The team included:
- Frontend engineers
- Backend engineers
- System Analysts (SA)
- Designers
- Product Managers (PM)
- QA testers

Collaboration was frequent with clear development rhythm.

### Tech Stack

**Backend**: Node.js, NestJS, PostgreSQL, GraphQL

**Frontend**: Next.js **(App Router)** with next-generation patterns:
- Server Components
- Dynamic/Parallel Routes
- Streaming rendering

---

## Project Background and Technical Challenges

This was a **large-scale B2B SaaS platform** integrating:
- Customer data
- Media assets
- Campaign management
- Budget tracking
- Reporting analytics

### My Responsibilities

I was responsible for **frontend interface module design and development**, and participated in planning the frontend logic for the **Form Flow Engine**.

The system involved extensive:
- Dynamic forms
- Nested fields
- Cross-page data transmission

Balancing **performance and consistency** was critical.

I closely aligned with **backend, SA, and design** on data flow and use cases, conducting multiple optimization rounds for:
- Browser performance
- State synchronization
- Loading strategies

I established **modular UI structure** and **shared logic components** at the architecture level, ensuring consistent expansion and maintenance across modules.

---

## GraphQL and Schema-Driven Development

The backend designed APIs with **GraphQL Schema** as the core, while the frontend developed and type-bound based on the same schema, forming **Schema-Driven Development**:

### Key Practices

**Query/Mutation Integration**:
- Used Query/Mutation to connect complex business data
- Managed caching and state with **Apollo Client**
- Combined with TypeScript type inference to reduce data inconsistency risks

**Server/Client Components Collaboration**:
- Handled Server/Client Components in App Router environment
- Tightly coupled UI and data layer with backend structure

**Shared Language**:
- Frontend and backend essentially "speak the same language"
- Improved communication precision and development efficiency

---

## Performance Optimization and Modular Design

With large data volumes, many form fields, and real-time validation, I systematically optimized rendering and data flow:

### Component Splitting and Loading Strategy

- **Lazy Loading, Suspense, Parallel/Nested Routes**
- Large forms broken into block rendering and conditional mounting
- Reduced first-screen load

### Interaction Load Management

- **Debounce/Throttle** for high-frequency inputs
- Deferred validation for non-critical fields
- Reduced unnecessary re-renders

### State Layer Separation

- Separated **UI State** from **Server State**
- Avoided global state amplification causing massive re-renders

### Error Recovery Experience

- Submission flow provides partial recovery
- Precise error prompts
- Maintains operation continuity

---

## API Data Fetching and Caching Strategy (GraphQL: Query / Mutation)

Under Apollo Client + GraphQL architecture, established Query/Mutation strategies centered on Schema, balancing consistency and performance:

### Type/Field Policies

- Set `keyFields` for core entities (Campaign, Order, Channel) enabling normalized cache
- Customized `merge/read` for list fields (campaigns, orders) supporting cursor/offset pagination and deduplication

### Cache Policies (Fetch Policies)

- **Default**: `cache-first` (fast revisits for lists/details)
- **Real-time pages**: `cache-and-network`
- **Admin operations**: `network-only` for strong consistency

### Optimistic UI & Cache Updates

- **Optimistic response** first, then correct with returned data
- Precisely update affected Queries in `update(cache, result)` (e.g., insert new Campaign into campaigns list)

### Cache Eviction & Refetch

- For sensitive states (approval/publish), selectively evict or `refetchQueries` after Mutation
- Only refresh necessary Queries
- Use Fragments (`writeFragment/readFragment`) for partial updates, avoiding broad refetches

### Pagination & Deduplication

- Cursor-based pagination with deduplication in merge
- Infinite scroll and progressive loading for long lists

### Batching, Concurrency, Retry

- Enabled **HTTP Batching** or Link-layer request merging to reduce RTT
- Enabled **dedup** to avoid duplicate Queries in short time
- Exponential backoff retry for recoverable errors, UI provides retry entry

### Auth & Visibility

- Apollo Link injects Token and tenant context
- Ensures data isolation and correct cache namespace

### Types & Codegen

- **GraphQL Codegen** generates TS types and Hooks
- Frontend develops directly aligned with Schema

### SSR/ISR Integration

- First screen via SSR/ISR for stability and SEO
- Interactive phase taken over by Apollo cache
- "SSR initial screen + client cache incremental" hybrid path

---

## Team Collaboration and Development Process

**Bi-weekly Sprints** with weekly code review and retrospectives.

I was responsible for:
- Module documentation
- Shared logic organization
- Establishing cross-functional communication mechanisms

This enabled **SA, design, and backend** to quickly align on frontend implementation constraints and requirements.

### Frontend Positioning

In large projects, I positioned frontend as the **bridge between user experience and data logic**:
- Interfaces must not only be user-friendly
- But also accurately reflect business and data rules

---

## Year-End Review

2023 was a year I accumulated **enterprise-level practical experience** in:
- Next.js App Router
- GraphQL Schema-Driven Development
- Performance optimization
- Modular design

I learned to collaborate precisely in **multi-functional teams**, advancing frontend value with a perspective that balances **architecture and experience**.

**Future Direction**:
- Continue with **frontend engineering as the core**
- Combine **product logic and system thinking**
- Embrace projects of even higher complexity

---

_Advancing with enterprise-scale architecture expertise and refined collaboration skills._
